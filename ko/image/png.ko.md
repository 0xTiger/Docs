{
  "date" : "2019-10-11",
  "keywords" :[ "png 파일", "png 파일 형식", "png 파일이란", "파일", "png 예", "png 파일 확장자","확장자", "형식" ],
  "author" : {
    "display_name" : "Kashif Iqbal"
},
  "draft" : "false",
  "toc" : true,
  "title" :"PNG 파일 형식 - 래스터 이미지 파일",
  "description":"PNG 파일 형식과 PNG 파일을 만들고 열 수 있는 API에 대해 알아보세요.",
  "linktitle" : "PNG",
  "menu" : {
    "docs" : {
      "parent" : "image"
}
},
  "lastmod" : "2019-09-10"
}

## PNG 파일이란?

**PNG**(Portable Network Graphics) 파일은 무손실 압축을 사용하는 래스터 이미지 파일 형식입니다. 이 파일 형식은 Graphics Interchange Format([GIF](/ko/image/gif/))을 대체하기 위해 생성되었으며 저작권 제한이 없습니다. 그러나 PNG 파일 형식은 애니메이션을 지원하지 않습니다. PNG 파일 형식은 무손실 이미지 압축을 지원하여 사용자들에게 인기가 있습니다. 시간이 지남에 따라 PNG는 널리 사용되는 이미지 파일 형식 중 하나로 발전했습니다.

## PNG 파일 형식의 간략한 역사

PNG 파일 형식을 만든 주된 이유는 GIF 파일 형식에 사용되는 특허 받은 압축 알고리즘인 Lempel-Ziv-Welch 때문입니다. 이는 다른 GIF 제한 사항과 함께 [**GIF**](/ko/image/gif/) 파일 형식을 대체해야 할 필요성을 발생시켰습니다. PNG 파일 형식에 대한 첫 번째 제안과 이름은 1995년 1월에 나왔습니다. PNG 파일 형식과 관련된 주요 이벤트는 다음과 같습니다.

* 1996년 10월: PNG 사양 버전 1.0이 출시되었으며 나중에 [RFC](https://en.wikipedia.org/wiki/Request_for_Comments) 2083으로 나타났습니다. 1996년 10월에 W3C 권장 사항이 되었습니다.
* 1998년 12월: 버전 1.1이 약간 변경되고 3개의 새로운 청크가 추가되었습니다.
* 1999년 8월: 하나의 추가 청크를 추가한 버전 1.2가 릴리스되었습니다.
* 2003년 11월: PNG가 국제 표준이 되었습니다(ISO/IEC 15948:2003). 이 PNG 버전은 버전 1.2와 약간만 다르며 새로운 청크를 추가하지 않습니다.
* 2004년 3월: ISO/IEC 15948:2004

## GIF와 PNG의 기능 비교

PNG 파일 형식은 간단하고 휴대 가능하며 법적으로 방해가 되지 않으며 상호 교환 가능하고 유연하고 견고하도록 설계되었습니다. 다음 표에는 새로운 기능 외에 PNG 파일 형식으로 상속되는 GIF 기능이 나열되어 있습니다.

|기능|GIF|PNG|
---|---|---|
|최대 256색의 인덱스 컬러 이미지|예|예|
|스트리밍 지원|예|예|
|투명성|예|예|
|보조 정보|예|예|
|하드웨어 및 플랫폼 독립|예|예|
|효과적|예|예|
|픽셀당 최대 48비트의 트루컬러 이미지|아니요|예|
|픽셀당 최대 16비트의 회색조 이미지|아니요|예|
|전체 알파 채널(일반 투명 마스크)|아니요|예|
|이미지 감마 정보|아니요|예|
|신뢰성|아니요|예|
|빠른 초기 프레젠테이션|아니요|예|

## PNG 파일 구조

거의 모든 운영 체제는 PNG 파일 열기를 지원합니다. 예를 들어, Microsoft Windows 뷰어에는 OS가 기본적으로 설치의 일부로 지원을 제공하므로 PNG 파일을 열 수 있는 기능이 있습니다. PNG 파일은 일련의 //청크//가 뒤따르는 PNG '서명'으로 구성됩니다.

### PNG 파일 헤더

PNG 파일의 처음 8바이트에는 항상 다음(십진수) 값이 포함됩니다.

{{{137 80 78 71 13 10 26 10 }}}

이 서명은 파일의 나머지 부분에 IHDR 청크로 시작하여 IEND 청크로 끝나는 일련의 청크로 구성된 단일 PNG 이미지가 포함되어 있음을 나타냅니다.

### 청크 ###

각 청크는 네 부분으로 구성됩니다.

**길이:** 청크의 데이터 필드에 있는 바이트 수를 제공하는 4바이트 부호 없는 정수입니다. 길이는 자체, 청크 유형 코드 또는 CRC가 아닌 데이터 필드만 계산합니다. 0은 유효한 길이입니다. 인코더와 디코더는 길이를 부호 없는 것으로 처리해야 하지만 그 값은 231바이트를 초과해서는 안 됩니다.

**청크 유형:** 4바이트 청크 유형 코드입니다. 설명의 편의와 PNG 파일 검사를 위해 유형 코드는 대문자와 소문자 ASCII 문자(AZ 및 az 또는 65-90 및 97-122 십진수)로 제한됩니다. 그러나 인코더와 디코더는 코드를 문자열이 아닌 고정 바이너리 값으로 처리해야 합니다. 예를 들어, 유형 코드 IDAT를 해당 문자에 해당하는 EBCDIC로 표현하는 것은 올바르지 않습니다. 청크 유형에 대한 추가 명명 규칙은 다음 섹션에서 설명합니다.

**청크 데이터:** 청크 유형에 해당하는 데이터 바이트(있는 경우). 이 필드는 길이가 0일 수 있습니다.

**CRC:** 청크 유형 코드 및 청크 데이터 필드를 포함하지만 길이 필드는 포함하지 않는 청크의 이전 바이트에서 계산된 4바이트 CRC(순환 중복 검사). 데이터가 포함되지 않은 청크의 경우에도 CRC는 항상 존재합니다.

청크 데이터 길이는 최대 바이트 수입니다. 따라서 구현자는 청크가 바이트보다 큰 경계에 정렬되어 있다고 가정할 수 없습니다.

청크는 각 청크 유형에 적용된 제한 사항에 따라 임의의 순서로 나타날 수 있습니다. (한 가지 주목할만한 제한은 IHDR이 먼저 나타나야 하고 IEND가 마지막에 나타나야 한다는 것입니다. 따라서 IEND 청크는 파일 끝 마커 역할을 합니다.) 동일한 유형의 여러 청크가 나타날 수 있지만 해당 유형에 대해 특별히 허용된 경우에만 가능합니다.

#### 청크 유형

청크 유형은 청크 유형에 할당된 4바이트 대소문자 구분 ASCII 값을 기반으로 **Critical** 및 **Ancillary** 청크로 분류됩니다. 모든 구현은 표준 중요 청크를 이해하고 성공적으로 렌더링해야 합니다. 유효한 PNG 이미지는 IHDR 청크, 하나 이상의 IDAT 청크 및 IEND 청크를 포함해야 합니다.

### 압축

PNG 압축 방법 0(현재 PNG에 대해 정의된 유일한 압축 방법)은 최대 32768바이트의 슬라이딩 윈도우로 수축/팽창 압축을 지정합니다. 수축 압축은 zip, gzip, pkzip 및 관련 프로그램에서 사용되는 LZ77 파생물입니다. 특허가 없는 상태를 뒷받침하는 광범위한 연구가 수행되었습니다. zlib 데이터 스트림 내의 압축 데이터는 일련의 블록으로 저장되며, 각 블록은 원시(압축되지 않은) 데이터, 고정 Huffman 코드로 인코딩된 LZ77 압축 데이터 또는 사용자 지정 Huffman 코드로 인코딩된 LZ77 압축 데이터를 나타낼 수 있습니다. 최종 블록의 마커 비트는 이를 마지막 블록으로 식별하여 디코더가 압축된 데이터 스트림의 끝을 인식할 수 있도록 합니다.

#### 사전 압축 필터링

최적의 압축을 위해 이미지 데이터를 준비하기 위해 사전 압축 필터가 적용됩니다. PNG 필터 방법은 다음과 같이 5가지 기본 필터 유형을 정의합니다.

|필터 유형|이름|예상 값|
---|---|---|
|0|없음|스캔라인이 수정되지 않고 전송됨|
|1|Sub|각 바이트와 이전 픽셀의 해당 바이트 값 간의 차이를 전송합니다.|
|2|Up|Up() 필터는 현재 픽셀의 왼쪽이 아니라 바로 위에 있는 픽셀이 예측자로 사용된다는 점을 제외하고 Sub() 필터와 같습니다.|
|3|Average|Average() 필터는 두 개의 인접 픽셀(왼쪽 및 위쪽)의 평균을 사용하여 픽셀 값을 예측합니다.|
|4|Paeth|Paeth() 필터는 세 개의 인접 픽셀(왼쪽, 위, 왼쪽 위)의 단순 선형 함수를 계산한 다음 계산된 값에 가장 가까운 인접 픽셀을 예측 변수로 선택합니다.|

필터링 알고리즘은 이미지의 비트 심도나 색상 유형에 관계없이 픽셀이 아닌 '바이트'에 적용됩니다. 필터링 알고리즘은 스캔라인에 의해 형성된 바이트 시퀀스에서 작동합니다. 이미지에 알파 채널이 포함된 경우 알파 데이터는 이미지 데이터와 동일한 방식으로 필터링됩니다.

이미지가 인터레이스되면 인터레이스 패턴의 각 패스는 필터링을 위해 독립적인 이미지로 처리됩니다. 필터는 패스 중에 실제로 전송된 픽셀에 의해 형성된 바이트 시퀀스에 대해 작동하며 "이전 스캔라인"은 전체 이미지에서 인접한 것이 아니라 동일한 패스에서 이전에 전송된 것입니다. 한 패스에서 전송된 하위 이미지는 항상 직사각형이지만 전체 이미지보다 너비 및/또는 높이가 더 작습니다. 이 하위 이미지가 비어 있으면 필터링이 적용되지 않습니다.

## 참조 ##

* [PNG - 홈페이지](http://www.libpng.org/pub/png/)

