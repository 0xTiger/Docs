{
  "date" : "2019-11-25",
  "keywords" :[ "jpeg 파일", "jpeg 파일 형식", "jpeg 파일이란", "파일", "jpeg 예", "jpeg 파일 확장자","확장자", "형식" ],
  "author" : {
    "display_name" : "Kashif Iqbal"
},
  "draft" : "false",
  "toc" : true,
  "title" :"JPEG - 이미지 파일 형식",
  "description":"JPEG 파일 형식과 JPEG 파일을 만들고 열 수 있는 API에 대해 알아보세요.",
  "linktitle" : "JPEG",
  "menu" : {
    "docs" : {
      "parent" : "image"
}
},
  "lastmod" : "2020-08-08"
}

## JPEG 파일이란? ##

JPEG는 손실 압축 방법을 사용하여 저장되는 이미지 형식의 한 유형입니다. 압축의 결과로 출력 이미지는 저장 크기와 이미지 품질 사이의 절충안입니다. 사용자는 압축 수준을 조정하여 원하는 품질 수준을 달성하는 동시에 저장 크기를 줄일 수 있습니다. 이미지에 10:1 압축을 적용하면 이미지 품질에 거의 영향을 미치지 않습니다. 압축 값이 높을수록 화질 저하가 커집니다.

## 파일 형식 사양 ##

JPEG 이미지 파일 형식은 Joint Photographic Experts Group에서 표준화했기 때문에 JPEG라는 이름이 붙었습니다. 형식은 웹에서 사진 이미지를 저장하고 전송하기 위해 선택되었습니다. 거의 모든 운영 체제에는 이제 종종 JPG 확장자로 저장되는 JPEG 이미지의 시각화를 지원하는 뷰어가 있습니다. 웹 브라우저에서도 JPEG 이미지의 시각화를 지원합니다. JPEG 파일 형식 사양으로 들어가기 전에 JPEG 생성과 관련된 단계의 전체 프로세스를 언급해야 합니다.

### JPEG 압축 단계 ###

**변환:** 컬러 이미지는 RGB에서 휘도/색차 이미지로 변환됩니다(눈은 색차가 아니라 휘도에 민감하므로 색차 부분은 많은 데이터를 잃을 수 있으므로 압축률이 높을 수 있습니다.

**다운 샘플링:** 다운 샘플링은 휘도 성분이 아니라 유색 성분에 대해 수행됩니다. 다운 샘플링은 수평으로 2:1 및 수직으로 1:1(2h 1 V)의 비율로 수행됩니다. 따라서 'y' 구성요소가 건드리지 않기 때문에 이미지의 크기가 줄어들고 이미지 품질의 눈에 띄는 손실이 없습니다.

**그룹으로 구성:** 행 또는 열의 수가 8의 배수가 아닌 경우 각 색상 구성 요소의 픽셀을 "데이터 단위"라고 하는 8×2 픽셀 그룹으로 구성하고 맨 아래 행과 맨 오른쪽 열이 중복됩니다.

**이산 코사인 변환:** 그런 다음 이산 코사인 변환(DCT)이 각 데이터 단위에 적용되어 변환된 구성요소의 8×8 맵을 생성합니다. DCT는 컴퓨터 산술의 제한된 정밀도로 인해 일부 정보 손실을 수반합니다. 즉, 지도가 없어도 이미지 품질이 약간 저하되지만 일반적으로 작습니다.

**양자화:** 데이터 단위의 64개 변환된 구성 요소 각각은 '양자화 계수(QC)'라는 별도의 숫자로 나눈 다음 정수로 반올림됩니다. 이것은 정보가 복구 불가능하게 손실되는 곳입니다. 큰 QC는 더 많은 손실을 유발합니다. 일반적으로 대부분의 JPEG 구현에서는 JPEG 표준에서 권장하는 QC 테이블을 사용할 수 있습니다.

**인코딩:** 각 데이터 단위의 64개의 양자화된 변환 계수(현재는 정수임)는 RLE 및 허프만 코딩의 조합을 사용하여 인코딩됩니다.

**헤더 추가:** 마지막 단계는 헤더와 사용된 모든 JPEG 매개변수를 추가하고 결과를 출력합니다.

JPEG 디코더는 압축된 이미지에서 원본 이미지를 생성하기 위해 역순으로 단계를 사용합니다.

### 파일 구조 ###

JPEG 이미지는 각 세그먼트가 마커로 시작하는 일련의 세그먼트로 표시됩니다. 각 마커는 0xFF 바이트로 시작하고 마커 유형을 나타내는 마커 플래그가 뒤따릅니다. 마커 다음에 오는 페이로드는 마커 유형에 따라 다릅니다. 일반적인 JPEG 마커 유형은 다음과 같습니다.

|짧은 이름|바이트|페이로드|이름|설명
---|---|---|---|---|
|SOI|0xFF, 0xD8|없음|이미지 시작|
|S0F0|0xFF, 0xC0|가변 크기|프레임 시작|
|S0F2|0xFF, 0xC2|가변 크기|프레임 시작|
|DHT|0xFF, 0xC4|가변 크기|허프만 테이블 정의|
|DQT|0xFF, 0xDB|가변 크기|양자화 테이블 정의|
|DRI|0xFF, 0xDD|4바이트|다시 시작 간격 정의|
|SOS|0xFF, 0xDA|가변 크기|스캔 시작|
|RSTn|0xFF, 0xD//n//(/ko//n//#0..7)|없음|다시 시작|
|APPn|0xFF, 0xE//n//|가변 크기|응용 프로그램별|
|COM|0xFF, 0xFE|가변 크기|설명|
|EOI|0xFF, 0xD9|없음|이미지 끝|

엔트로피 코딩된 데이터 내에서 0xFF 바이트 뒤에 인코더에 의해 다음 바이트 앞에 0x00 바이트가 삽입되어 아무 표시도 표시되지 않아 프레이밍 오류를 방지합니다. 디코더는 이 0x00 바이트를 건너뛰어야 합니다. [바이트 스터핑](https://en.wikipedia.org/wiki/Byte_stuffing)(JPEG 사양 섹션 F.1.2.3 참조)이라고 하는 이 기술은 마커 페이로드 데이터가 아닌 엔트로피 코딩된 데이터에만 적용됩니다. . 그러나 엔트로피 코딩된 데이터에는 몇 가지 자체 마커가 있습니다. 특히 리셋 마커(0xD0 ~ 0xD7)는 병렬 디코딩을 허용하기 위해 엔트로피 코딩된 데이터의 독립적인 청크를 분리하는 데 사용되며 인코더는 이러한 리셋 마커를 일정한 간격으로 자유롭게 삽입할 수 있습니다(모든 인코더가 이 작업을 수행하는 것은 아님).

