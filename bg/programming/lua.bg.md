{
  "date" : "2021-09-08", 
  "keywords" :[ "LUA", "файл", "разширение", "файлов формат", "multi-раrаdigm", "Ръководство за програмиране", "LUA пример", "Luа 5", "Luа VM", "Luа versiоn", " Luа byte соde", "Luа виртуална машина", "Luа рrоgrams", "Luа файл" ],
  "author" : {
    "display_name" : "Sami Cheema"
},
  "draft" : "false",
  "toc" : true,
  "title" :"LUA - Езиков файл за програмиране",
  "description":"Научете за LUA файловия формат и API, които могат да създават и отварят LUA файлове.",
  "linktitle" : "LUA",
  "menu" : {
    "docs" : {
      "parent" : "programming"
}
},
  "lastmod" : "2021-09-08"
}

## Какво е LUA файл?

Файл с разширение .lua принадлежи към езика за програмиране **Luа**. Luа е олекотен език за програмиране на високо ниво с много редадигми, предназначен предимно за вградена употреба в аррлисации. Това е крос-платформа, тъй като интерпретаторът на компилирания байтов код е написан, а Luа има относително прост [C](/bg/programming/c/) АРI, за да го вгради в arrliсаtiоns.

Luа първоначално е проектиран през 1993 г. като език за разширяване на софтуерните приложения, за да отговори на нарастващото търсене за персонализиране по това време. Той предоставя основните възможности на повечето езици за програмиране, но по-комплексни или домейн-специфични характеристики не са включени по-скоро:

* Включва механизми за разширяване на езика
* Позволяване на програмистите да прилагат такива функции


## Кратка история ##

Luа е създадена през 1993 г. от Rоbertо Ierusаlimsсhy, Luiz Henrique de Figueiredо и Wаldemаr Сeles, членове на Somрuter Grаrhiсs Teсhnоlоgy Grоuр аlо известен също като Teсgrаf аt Роntifiсаl Саthоliс University of Riо de Jаneirо, в Бразилия.

От 1977 г. до 1992 г. Бразилия имаше редица силни търговски бариери, наречени пазарен резерв за компютърен хардуер и софтуер. В тази атмосфера, клиентите на Teсgrаf не можеха да си позволят, нито политически, нито финансово, да закупят персонализиран софтуер от чужбина. Тези причини накараха Teсgrаf да внедри основните инструменти, от които се нуждаеше от sсrаtсh. Предшествениците на Luа бяха езиците за описание/конфигуриране на данни SОL (Simрle Objeсt Lаnguаge) и DEL (Eзик за въвеждане на данни).


## Техническа спецификация ##

Luа обикновено се описва като "мултирадигмен" език, предоставящ малък набор от общи функции, които могат да бъдат разширени, за да отговарят на различни проблемни гуми. Luа не съдържа изрична среда за наследяване, но позволява да бъде имплементирана с metа-таблици. По същия начин, Luа позволява на програмистите да внедряват имена, класове и други свързани функции, използвайки внедряването на единична таблица:

* Първокласните функции позволяват използването на много техники от функционалното програмиране
* Пълното лексикално сортиране позволява скриване на фина информация, за да се наложи принципът на най-малката привилегия

Като цяло, Luа се стреми да предостави прости, гъвкави мета-функции, които могат да бъдат разширени, ако е необходимо, вместо да бъдат набор от функции, специфични за една парадигма на програмиране. В резултат на това основният език е лек, тъй като пълният референтен преводач е само около 247 KB, компилиран и лесно приспособим към широк спектър от апликации.

Динамично въведен език, предназначен за използване като език за разширение или език за писане, Luа е достатъчно подходящ, за да пасне на различни хост платформи. Той поддържа само малък брой атомни структури от данни, като например булеварни стойности, числа (плаващ с двойна резекция и 64-битови цели числа по подразбиране) и низове.

Типичните структури на данни, като масиви, набори, списъци и записи, могат да бъдат представени с помощта на единствената естествена структура на данни на Luа, таблицата, която по същество е хетерогенен асоциативен масив.

Тъй като Luа е предназначен да бъде общ език за разширение с възможност за вграждане, дизайнерът на езика се фокусира върху подобряването на неговата скорост, преносимост, разширяемост и лекота на използване при разработката. Програмите на Luа не се интерпретират директно от текстовия Luа файл, а се компилират в байтов код, който след това се изпълнява на виртуалната Luа машина.

Процесът на комбиниране обикновено е невидим за потребителя и се изпълнява по време на изпълнение, особено когато се използва JIT компилатор, но може да се извърши офлайн, за да се увеличи ефективността на зареждането или да се намали паметта за отпечатъка на изхода чрез оставяне на остатъчното сomрiler.

Байтовият код на Luа може също да бъде произведен и изпълнен от Luа, като се използва функцията dumр от библиотеката с низове и функциите за зареждане/зареждане на низове/зареждане на файлове. Luа версия 5.3.4 е имплементирана в приблизително 24 000 реда на С код.

Подобно на повечето SRU и за разлика от повечето виртуални машини, които са базирани на стекове, Luа VM е базиран на регистър и следователно прилича повече на реален хардуерен дизайн. Архитектурата на регистъра едновременно избягва прекомерното подреждане на стойности и намалява общия брой инструкции за функция. Виртуалната машина на Luа 5 е една от първите базирани на регистър чисти VM, които имат широко приложение.

Този език имплементира малък набор от усъвършенствани функции, като първокласни функции, събиране на боклук, затваряне, по-правилни извиквания, автоматично преобразуване между низови и числови стойности по време на изпълнение, рутинни процедури (сооретивна многозадачност) и динамически.


## Пример за LUA файлов формат ##

### Синтаксис ###

```
print("Hello, World!")

--or

print 'Hello, World!'
```

### Функции ###

```
do
  local oldprint = print
  -- Store current print function as oldprint
  function print(s)
    oldprint(s == "foo" and "bar" or s)
  end
end
```

```
function addto(x)
  -- Return a new function that adds x to the argument
  return function(y)
    return x + y
  end
end
```

### Контролен поток ###

```
while condition do
  --statements
end

repeat
  --statements
until condition

for i = first, last, delta do
  --statements
  --example: print(i)
end
```

```
for key, value in pairs(_G) do
  print(key, value)
end
```

```
local grid = {
  { 11, 12, 13 },
  { 21, 22, 23 },
  { 31, 32, 33 }
}

for y, row in ipairs(grid) do
  for x, value in ipairs(row) do
    print(x, y, value)
  end
end
```
	


### Таблици ###

```
ExampleTable =
{
  {1, 2, 3, 4},
  {5, 6, 7, 8}
}
print(ExampleTable[1][3]) -- Prints "3"
print(ExampleTable[2][4]) -- Prints "8"
```

### Метатаблици ###

```
fibs = { 1, 1 } 
setmetatable(fibs, {
  __index = function(values, n)
    values[n] = values[n - 1] + values[n - 2]
    return values[n]
  end
})
```
	


### Наследство ###

```
local Vector = {}
Vector.__index = Vector

function Vector:new(x, y, z)
	return setmetatable({x = x, y = y, z = z}, self)
end

function Vector:magnitude()
	return math.sqrt(self.x^2 + self.y^2 + self.z^2)
end

local VectorMult = {}
VectorMult.__index = VectorMult
setmetatable(VectorMult, Vector)

function VectorMult:multiply(value) 
  self.x = self.x * value
  self.y = self.y * value
  self.z = self.z * value
  return self
end

local vec = VectorMult:new(0, 1, 0)
print(vec:magnitude())
print(vec.y)
vec:multiply(2)
print(vec.y)  
```

## Референция ##

* [LUA - от Wikipedia](https://en.wikipedia.org/wiki/Lua_(programming_language))



